<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <div>
        <img src="../../assets/images/demo3.png" alt="">
    </div>
    <script>
        window.onload = function () {
            // 试编写"智能重复"smartRepeat函数，实现：

            // 将3[abc]变为abcabcabc
            // 将3[2[a]2[b]]变为aabbaabbaabb
            // 将2[1[a]3[b]2[3[c]4[d]]变为abbbcccddddcccddddabbbcccddddcccdddd

            // 不用考虑输入字符串是非法的情况，比如：
            // 2[a3[b]]是错误的，应该补一个1，即2[1[a]3[b]]
            // [abc]是错误的，应该补一个1，即1[abc]
            let templateStr = '3[2[7abc]4[d]]';

            function smartRepeat(templateStr) {
                // 指针
                let index = 0;
                // 栈1，存放数字
                let stack1 = [];
                // 栈2，存放字符串
                let stack2 = [];
                // 剩余部分
                let rest = templateStr

                while(index < templateStr.length - 1) {
                    // 剩余部分
                    rest = templateStr.substring(index);
                    // 看当前剩余部分是不是以数字和[开头
                    if(/^\d+\[/.test(rest)) {
                        // 得到数字
                        let times = Number(rest.match(/^(\d+)\[/)[1]);

                        // 就把数字压栈，把空字符串压栈
                        stack1.push(times);
                        stack2.push('');

                        // 让指针后移，times这个数字是多少位就后移多少位加1位，加的1位是[
                        index += times.toString().length + 1;
                    } else if (/^\w+\]/.test(rest)) {
                        // 如果这个字符试字母，那么此时就把栈顶这项改为这个字母
                        let word = rest.match(/^(\w+)\]/)[1];
                        stack2[stack2.length - 1] = word;

                        // 让指针后移，word这个字符是多少位就后移多少位
                        index += word.length;
                    } else if (rest[0] === ']'){
                        // 如果这个字符是]，那么就①将stack1弹栈，②stack2弹栈，
                        // ③就把字符串栈的新栈顶的元素重复刚弹出的那个字符串值指定次数拼接到新栈顶上
                        let times = stack1.pop();
                        let word = stack2.pop();
                        stack2[stack2.length - 1] += word.repeat(times);

                        index++;
                    }

                    // console.log(templateStr, index, JSON.stringify(stack1), JSON.stringify(stack2));
                }

                // while结束之后，stack1和stack2中肯定还剩1项，如果剩的个数不对，那就是用户的问题，方括号没有闭合
                return stack2[0].repeat(stack1[0]);
            }

            console.log(smartRepeat(templateStr));
        }
    </script>
</body>
</html>
